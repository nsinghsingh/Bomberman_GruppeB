package forms;import client.ClientMain;import lombok.Getter;import java.util.Date;import tiles.*;import javax.swing.*;import java.awt.*;import java.awt.event.KeyEvent;import java.awt.event.KeyListener;import java.util.ArrayList;import java.util.HashMap;/**This class has the GUI for the game and it loads the map on which the players play. It also sends messages to theserver and receives messages. These messages indicate which functionality needs to be triggered. **/public class Labyrinth implements KeyListener {    @Getter private JPanel Labyrinth;    @Getter private JPanel GameRender; //Getter is needed for a test    private JPanel GameInfo;    private JLabel Time;    private JPanel ClockIcon;    private JLabel P1Score;    private JLabel P2Score;    private JLabel P3Score;    private JLabel P4Score;    private JLabel TieScore;    private JPanel TieIcon;    private JPanel P4Icon;    private JPanel P3Icon;    private JPanel P2Icon;    private JPanel P1Icon;    private JLabel Clock;    private JLabel P1;    private JLabel Tie;    private JLabel P4;    private JLabel P3;    private JLabel P2;    public int[] playerScores = new int[4];    public int count = 900;    public int ties = 0;    final static int Y_LENGTH = 12;    final static int X_LENGTH = 22;    final int DELAY = 300;    @Getter final ClientMain CLIENT;    @Getter final int CLIENT_ID;    @Getter private long lastRequest;    @Getter private BasicTile[][] tiles = new BasicTile[Y_LENGTH][X_LENGTH];    @Getter private HashMap<Integer, BasicTile> tileTypes = new HashMap<>();    @Getter private ArrayList<Player> players = new ArrayList<>();    //Starts the class with an identificator for the client it belongs to    public Labyrinth(ClientMain client){        CLIENT_ID = client.clientID;        CLIENT = client;        tileTypes.put(0, new EmptyTile());        tileTypes.put(1, new UndestroyableBlock());        tileTypes.put(2, new DestroyableBlock());        tileTypes.put(3, new Player(this));    }    //Make a default test map    public void makeMap(){        int[][] mapValues = new int[12][22];        mapValues[0] = new int[]{1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1};        mapValues[11] = mapValues[0];        mapValues[1][1] = 3;        mapValues[10][1] = 3;        mapValues[1][20] = 3;        mapValues[10][20] = 3;        for (int i = 0; i < mapValues[0].length-4; i++) {            mapValues[1 + i % 2][i+2] = 2;            mapValues[3 + i % 2][i+2] = 2;            mapValues[5 + i % 2][i+2] = 2;            mapValues[7 + i % 2][i+2] = 2;            mapValues[9 + i % 2][i+2] = 2;        }        for (int i = 0; i < mapValues.length; i++) {            mapValues[i][0] = 1;            mapValues[i][21] = 1;        }        loadMap(mapValues);    }    //Adds all tiles to the interference    public void loadMap(int[][] mapValues){        if(loadArray(mapValues)){            GridLayout playingField = new GridLayout(Y_LENGTH, X_LENGTH, 0, 0);            GameRender.setLayout(playingField);            for (int i = 0; i < tiles.length; i++) {                for (int j = 0; j < tiles[i].length; j++) {                    GameRender.add(tiles[i][j]);                }            }        }        else{            GameRender.add(new JLabel("Looks like the map wasn't valid"));        }    }    /*    Uses the integers as keys to get the corresponding tile from the hashmap with all the tiles if mapValues is long    enough. If the tile is a player, it will be saved in the player list for later use     */    public boolean loadArray(int[][] mapValues){        if (tiles.length == mapValues.length && tiles[0].length == mapValues[0].length){            int playerIndex = 0;            for (int i = 0; i < mapValues.length; i++) {                for (int j = 0; j < mapValues[i].length; j++) {                    tiles[i][j] = tileTypes.get(mapValues[i][j]).clone();                    if(mapValues[i][j] == 3){                        players.add((Player) tiles[i][j]);                        players.get(players.size() -1).setPlayer(playerIndex);                        playerIndex++;                    }                }            }            return checkMap();        }        else return false;    }    //Checks if the map has four players in the corresponding position    public boolean checkMap(){        if (!(tiles[1][1] instanceof Player)){ return false; }        if (!(tiles[1][X_LENGTH-2] instanceof Player)){ return false; }        if (!(tiles[Y_LENGTH-2][1] instanceof Player)){ return false; }        return tiles[Y_LENGTH - 2][X_LENGTH - 2] instanceof Player;    }    //Adds a point to every player who is alive and updates the GUI    private void updateScoreboard(){        for (int i = 0; i < players.size(); i++) {            if (!players.get(i).isDead()) {                playerScores[i]++;            }            P1Score.setText(Integer.toString(playerScores[0]));            P2Score.setText(Integer.toString(playerScores[1]));            P3Score.setText(Integer.toString(playerScores[2]));            P4Score.setText(Integer.toString(playerScores[3]));        }    }    //Ends the game when there are 3 dead players    public void endGame(){        int counter = 0;        for (Player player: players) {            if(player.isDead()){                counter++;            }        }        if(counter <= 3){            //TODO end game        }    }    //Gets a message from the client and runs the corresponding method    public void updateLabyrinth(String action, int playerId){        if(!players.get(playerId).isDead()){            switch (action){                case "b":                    players.get(playerId).placeBomb();                    break;                case "k":                    players.get(playerId).die();                    updateScoreboard();                    endGame();                    break;                default:                    players.get(playerId).setDirection(action);            }        }    }    @Override    public void keyReleased(KeyEvent e) { }    @Override    public void keyTyped(KeyEvent e) { }    //Sends a message to the client with the input from the user    @Override    public void keyPressed(KeyEvent e) {        Date date = new Date();        if(date.getTime() - lastRequest > DELAY){            lastRequest = date.getTime();            if (e.getKeyCode() == KeyEvent.VK_W) {                CLIENT.sendMessage("method;w;" + CLIENT_ID);            }            if(e.getKeyCode() == KeyEvent.VK_S){                CLIENT.sendMessage("method;s;" + CLIENT_ID);            }            if(e.getKeyCode() == KeyEvent.VK_A){                CLIENT.sendMessage("method;a;" + CLIENT_ID);            }            if(e.getKeyCode() == KeyEvent.VK_D){                CLIENT.sendMessage("method;d;" + CLIENT_ID);            }            if(e.getKeyCode() == KeyEvent.VK_SPACE){                CLIENT.sendMessage("method;b;" + CLIENT_ID);            }        }    }    //Counts down the time left for the game    private void createUIComponents(){        Timer timer = new Timer(1000, null);        Time = new JLabel("...");        timer.addActionListener(e -> {        count--;        String countdown = String.format("%02d:%02d", count / 60, count % 60);            if (count >= 0) {                Time.setText(countdown);            } else {                ties++;                TieScore.setText(Integer.toString(ties));                P1Score.setText(Integer.toString(ties));                P2Score.setText(Integer.toString(ties));                P3Score.setText(Integer.toString(ties));                P4Score.setText(Integer.toString(ties));                timer.stop();            }        });        timer.setInitialDelay(0);        timer.start();    }}